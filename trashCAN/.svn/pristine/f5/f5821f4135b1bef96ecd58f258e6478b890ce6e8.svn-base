using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ItrashCAN;

namespace EPS_Controller
{
    class EPSMessage
    {
        public VC_STATE VCState;
        public EPS_COMMAND EPS_COMMAND;
        public EPS_OPERATING_STATE SoftwarePowerPlantEnable;
        public Byte Spare;
        public TORPEDO_CONFIGURATION TorpedoConfiguration;
        public Byte CommandMessageCounter;

        public EPSMessage()
        {
            VCState = VC_STATE.VC_Off;
            TorpedoConfiguration = TORPEDO_CONFIGURATION.Undefined;
            CommandMessageCounter = 0;
            Spare = 0;
            EPS_COMMAND = EPS_COMMAND.EPS_NOP;
            SoftwarePowerPlantEnable = EPS_OPERATING_STATE.EPS_OPERATING_STATE_NOT_PERMITTED;
        }

        public CANMsg ToCANMsg()
        {
            CANMsg CmdMessage = new CANMsg();

            CmdMessage.CANData = new byte[8];
            CmdMessage.CANId = (uint)CAN_MESSAGE_ID.CAN_ID_COMMAND_MSG;
            CmdMessage.ExtendedID = false;
            CmdMessage.RTR = false;

            CmdMessage.CANData[0] = (byte)VCState;
            CmdMessage.CANData[1] = (byte)EPS_COMMAND;
            CmdMessage.CANData[2] = (byte)SoftwarePowerPlantEnable;
            CmdMessage.CANData[3] = (byte)0;
            CmdMessage.CANData[4] = (byte)0;
            CmdMessage.CANData[5] = 0xFF;
            CmdMessage.CANData[6] = (byte)TorpedoConfiguration;
            CmdMessage.CANData[7] = CommandMessageCounter;

            return CmdMessage;
        }
    }

    class EPSReponseMessage
    {
        public EPS_STATES Current_EPS_State;
        public byte EPS_BIT_Flags;
        public byte EPS_Status_Flags;
        public byte RemainingRunTimeAtCurrentSpeed;
        public ushort MeasuredRPM;
        public byte EPS_BIT_Code;
        public byte EPS_ResponseMessageCounter;

        public EPSReponseMessage()
        {
            Current_EPS_State = EPS_STATES.EPS_Off;
            EPS_BIT_Flags = 0;
            RemainingRunTimeAtCurrentSpeed = 0;
            MeasuredRPM = 0;
            EPS_BIT_Code = 0;
            EPS_Status_Flags = 0;
            EPS_ResponseMessageCounter = 0;
        }

        public EPSReponseMessage(CANMsg Msg)
        {
            if ((CAN_MESSAGE_ID)Msg.CANId != CAN_MESSAGE_ID.CAN_ID_REPONSE_MSG)
            {
                throw new Exception("Message does not have the ID of a Reponse Message!");
            }
            else
            {
                /*Current_EPS_State = (EPS_STATES)Msg.CANData[0];
                EPS_BIT_Flags = Msg.CANData[1];
                EPS_Status_Flags = Msg.CANData[2];
                RemainingRunTimeAtCurrentSpeed = Msg.CANData[3];
                MeasuredRPM = (ushort)((Msg.CANData[4] << 8) + Msg.CANData[5]);
                EPS_BIT_Code = Msg.CANData[6];
                EPS_ResponseMessageCounter = (Msg.CANData[7]);*/
            }
        }

    }

    class EPS_InternalMessage1
    {
        /*/Raw Data Types
        public byte ControlInputs = 0;
        //Bit 0 --> Start Permit
        //Bit 1 --> One PPS (Instaneous value)
        //Bit 2 --> Misc Input
        //
        public byte EncoderState = 0;
        //Bit 0 --> Phase A
        //Bit 1 --> Phase B
        //Bit 2 --> Phase C
        //Bit 3 --> Direction

        const byte START_PERMIT_BIT_MASK = 0x01;
        const byte ONE_PPS_BIT_MASK = 0x02;
        const byte MISC_INPUT_BIT_MASK = 0x04;

        const byte ENCODER_PH_A_BIT_MASK = 0x01;
        const byte ENCODER_PH_B_BIT_MASK = 0x02;
        const byte ENCODER_PH_C_BIT_MASK = 0x04;
        const byte ENCODER_DIR_BIT_MASK = 0x08;

        //Decoded states

        public bool StartPermitActive = false;
        public bool OnEPSActive = false;
        public bool MiscInputActive = false;
        public bool Encoder_Ph_A = false;
        public bool Encoder_Ph_B = false;
        public bool Encoder_Ph_C = false;
        public bool Encoder_Dir = false;


        public EPS_InternalMessage1(CANMsg InMsg)
        {
            if ((EPS.CAN_MESSAGE_ID)InMsg.CANId == CAN_MESSAGE_ID.CAN_ID_INTERNAL_MSG_1)
            {
                ControlInputs = InMsg.CANData[0];
                EncoderState = InMsg.CANData[1];

                //CONTROL INPUTS
                if ((ControlInputs & START_PERMIT_BIT_MASK) > 0)
                    StartPermitActive = true;
                else
                    StartPermitActive = false;

                if ((ControlInputs & ONE_PPS_BIT_MASK) > 0)
                    OnEPSActive = true;
                else
                    OnEPSActive = false;

                if ((ControlInputs & MISC_INPUT_BIT_MASK) > 0)
                    MiscInputActive = true;
                else
                    MiscInputActive = false;

                //ENCODER STATE
                if ((EncoderState & ENCODER_PH_A_BIT_MASK) > 0)
                    Encoder_Ph_A = true;
                else
                    Encoder_Ph_A = false;

                if ((EncoderState & ENCODER_PH_B_BIT_MASK) > 0)
                    Encoder_Ph_B = true;
                else
                    Encoder_Ph_B = false;

                if ((EncoderState & ENCODER_PH_C_BIT_MASK) > 0)
                    Encoder_Ph_C = true;
                else
                    Encoder_Ph_C = false;

                if ((EncoderState & ENCODER_DIR_BIT_MASK) > 0)
                    Encoder_Dir = true;
                else
                    Encoder_Dir = false;

            }
            else
            {
                throw new Exception("CAN Message IS is not CAN_ID_INTERNAL_MSG_1.  Expecting " + CAN_MESSAGE_ID.CAN_ID_INTERNAL_MSG_1 +
                     " recieved " + InMsg.CANId);

            }
        }
        */
    }

    enum ATT_SUPERSTATES
    {
        SUPERSTATE_OFF = 0x00,
        SUPERSTATE_BOOTLOADER = 0xF0,
        SUPERSTATE_STANDBY = 0x10,
        SUPERSTATE_READY = 0x20,
        SUPERSTATE_LAUNCH = 0x30,
        SUPERSTATE_OPERATING = 0x40,
        SUPERSTATE_SHUTDOWN = 0x50,
        SUPERSTATE_NOT_READY = 0xA0,
        SUPERSTATE_TEST = 0xB0
    };

    enum EPS_TEST_SUBSTATES
    {
        Test_ManualControl = 0x01
    };

    enum EPS_OFF_SUBSTATES
    {
        Off_Off = 0x01
    }

    public enum EPS_STATES
    {
        EPS_Off = ATT_SUPERSTATES.SUPERSTATE_OFF + EPS_OFF_SUBSTATES.Off_Off,
        EPS_Test_ManualControl = ATT_SUPERSTATES.SUPERSTATE_TEST + EPS_TEST_SUBSTATES.Test_ManualControl
    };

    public enum EPS_COMMAND
    {
        EPS_NOP = 0,
        EPS_SEND_INTERNAL_DATA = 0x12,
        EPS_STOP_INTERNAL_DATA = 0x14,
        EPS_Test_ManualControl = EPS_STATES.EPS_Test_ManualControl,
        EPS_Off = EPS_STATES.EPS_Off
    };

    public enum VC_STATE
    {
        VC_Off = 0x00,
        VC_Standby_Initialize = 0x11,
        VC_Standby_WaitPresets = 0x12,

        VC_Ready_InitialPresetsValid = 0x21,
        VC_Ready_WaitIntLaunchReqSig = 0x22,
        VC_Ready_WaitLaunchReqMsg = 0x23,
        VC_Ready_WaitFinalPresets = 0x24,
        VC_Ready_WaitSquibFireMsg = 0x25,

        VC_Launch_WaitIntPower = 0x31,
        VC_Launch_WaitFirstMotion = 0x32,
        VC_Launch_BoreRiding = 0x33,
        VC_Launch_AeroFlight = 0x34,
        VC_Launch_WaterEntry = 0x35,
        VC_Launch_TransitionToFlight = 0x36,

        VC_Operating_WaitPlatformSeparation = 0x41,
        VC_Operating_RunToMissionEnable = 0x42,
        VC_Operating_VCControl = 0x43,
        VC_Operating_GCControl = 0x44,
        VC_Operating_EndOfRunManeuvers = 0x45,

        VC_Shutdown_Delay = 0x51,
        VC_Shutdown_PowerDown = 0x52,

        VC_NotReady_BITFail = 0xA1,

        VC_Test_WaitTestCommand = 0xB1,
        VC_Test_UpdatingCode = 0xB2,
        VC_Test_PerformingCommandedBIT = 0xB4,
        VC_Test_UpdatingCalibration = 0xB5,
        VC_Test_SendRecordedData = 0xB6,
        VC_Test_EraseRecordedData = 0xB7,
        VC_Test_SendRawData = 0xB8,
        VC_Test_SendVersions = 0xBA,
        VC_Test_TestOutputs = 0xBB,
        VC_Test_EchoCalibration = 0xBC
    };

    public enum TORPEDO_CONFIGURATION
    {
        Warshot = 0x11,
        ExerciseInertInstrumentedWarheadThermal = 0x22,
        ExerciseFieldExerciseSectionThermal = 0x33,
        ExerciseInertInstrumentedWarheadElectric = 0x44,
        ExerciseFieldExerciseSectionElectric = 0x55,
        Undefined = 0xFC
    };

    public enum EPS_OPERATING_STATE
    {
        EPS_OPERATING_STATE_PERMITTED_1 = 0x11,
        EPS_OPERATING_STATE_PERMITTED_2 = 0x22,
        EPS_OPERATING_STATE_NOT_PERMITTED = 0x00
    };

    public enum CAN_MESSAGE_ID : uint
    {
   CAN_ID_COMMAND_MSG                     =0x38,
   CAN_ID_REPONSE_MSG                     =0x39,
   CAN_ID_VEHICLE_DATA_NETWORK_TIME_MSG   =0x34,
   CAN_ID_INTERNAL_MSG_1                  =0x438,
   CAN_ID_INTERNAL_MSG_2                  =0x439,
   CAN_ID_INTERNAL_MSG_3                  =0x43A,
   CAN_ID_INTERNAL_MSG_4                  =0x43B,
   CAN_ID_INTERNAL_MSG_5                  =0x43C,
   CAN_ID_INTERNAL_MSG_6                  =0x43D,
   CAN_ID_INTERNAL_MSG_7                  =0x43E,
   CAN_ID_INTERNAL_MSG_8                  =0x43F,
   CAN_ID_SUBSYSTEM_VERSION_MSG           =0x4B8,


  CAN_ID_TEST_COMMAND_MSG                 =0x5B8,
  CAN_ID_TEST_REPONSE_MSG                 =0x5B9,
  CAN_ID_TEST_CAL_DOWNLOAD_MSG            =0x5BA,
  CAN_ID_TEST_DATA_UPLOAD_MSG             =0x5BB,
  CAN_ID_UPDATE_CODE_COMMAND_MSG          =0x638,
  CAN_ID_UPDATE_CODE_RESPONSE_MSG         =0x639,
  CAN_ID_UPDATE_CODE_DOWNLOAD_MSG         =0x63A,
  CAN_ID_UPDATE_CODE_UPLOAD_MSG           =0x63B
    };


    public enum EPS_TEST_COMMAND
    {
        MANUAL_COMMUTATION_SETTINGS = 1
    };
    /*
    public class EPS_ManualCommutationSettings
    {
        public EPS_TEST_COMMAND TestCommand = EPS_TEST_COMMAND.MANUAL_COMMUTATION_SETTINGS;
        public byte DutyCycle = 0;
        public FPGA_COMMUTATION_DIRECTION CommutationDirection = FPGA_COMMUTATION_DIRECTION.FORWARD;
        public FPGA_COMMUTATION_MODE CommutationMode = FPGA_COMMUTATION_MODE.CLOSED_LOOP;
        public FPGA_MANUAL_PHASE_MODE ManualPhase = FPGA_MANUAL_PHASE_MODE.BRAKE;
        public uint CommutationRate = 0;

        public EPS_ManualCommutationSettings()
        {
            TestCommand = EPS_TEST_COMMAND.MANUAL_COMMUTATION_SETTINGS;
            DutyCycle = 0;
            CommutationDirection = FPGA_COMMUTATION_DIRECTION.FORWARD;
            CommutationMode = FPGA_COMMUTATION_MODE.CLOSED_LOOP;
            ManualPhase = FPGA_MANUAL_PHASE_MODE.BRAKE;
            CommutationRate = 0;
        }

        public CANMsg ToCANMsg()
        {
            CANMsg Msg = new CANMsg();

            Msg.CANId = (uint)CAN_MESSAGE_ID.CAN_ID_TEST_COMMAND_MSG;
            Msg.CANData = new byte[8];
            Msg.ExtendedID = false;
            Msg.RTR = false;
            Msg.CANData[0] = (byte)TestCommand;
            Msg.CANData[1] = (byte)DutyCycle;
            Msg.CANData[2] = (byte)((byte)CommutationDirection | (byte)((byte)(ManualPhase) << 1));
            Msg.CANData[3] = (byte)CommutationMode;
            Msg.CANData[4] = (byte)(CommutationRate >> 24);
            Msg.CANData[5] = (byte)(CommutationRate >> 16);
            Msg.CANData[6] = (byte)(CommutationRate >> 8);
            Msg.CANData[7] = (byte)(CommutationRate);

            return Msg;
        }

    }*/
}
