using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using ItrashCAN;

namespace EPPS
{
    class EPPSMessage
    {
        public VC_STATE VCState;
        public EPPS_COMMAND EPPS_Command;
        public EPPS_OPERATING_STATE SoftwarePowerPlantEnable;
        public UInt16 RPM_Command;
        public Byte Spare;
        public TORPEDO_CONFIGURATION TorpedoConfiguration;
        public Byte CommandMessageCounter;
        
        public EPPSMessage()
        {
            VCState = VC_STATE.VC_Off;
            TorpedoConfiguration = TORPEDO_CONFIGURATION.Undefined;
            CommandMessageCounter = 0;
            RPM_Command = 0;
            Spare = 0;
            EPPS_Command = EPPS_COMMAND.EPPS_NOP;
            SoftwarePowerPlantEnable = EPPS_OPERATING_STATE.EPPS_OPERATING_STATE_NOT_PERMITTED;
        }

        public CANMsg ToCANMsg()
        {
            CANMsg CmdMessage = new CANMsg();

            CmdMessage.CANData = new byte[8];
            CmdMessage.CANId = (uint)CAN_MESSAGE_ID.CAN_ID_COMMAND_MSG;
            CmdMessage.ExtendedID = false;
            CmdMessage.RTR = false;

            CmdMessage.CANData[0] = (byte)VCState;
            CmdMessage.CANData[1] = (byte)EPPS_Command;
            CmdMessage.CANData[2] = (byte)SoftwarePowerPlantEnable;
            CmdMessage.CANData[3] = (byte)(RPM_Command>>8);
            CmdMessage.CANData[4] = (byte)(RPM_Command);
            CmdMessage.CANData[5] = 0xFF;
            CmdMessage.CANData[6] = (byte)TorpedoConfiguration;
            CmdMessage.CANData[7] = CommandMessageCounter;

            return CmdMessage;
        }
    }

    class EPPSReponseMessage
    {
        public EPPS_STATES Current_EPPS_State;
        public byte EPPS_BIT_Flags;
        public byte EPPS_Status_Flags;
        public byte RemainingRunTimeAtCurrentSpeed;
        public ushort MeasuredRPM;
        public byte EPPS_BIT_Code;
        public byte EPPS_ResponseMessageCounter;

        public EPPSReponseMessage()
        {
            Current_EPPS_State = EPPS_STATES.EPPS_Off;
            EPPS_BIT_Flags = 0;
            RemainingRunTimeAtCurrentSpeed = 0;
            MeasuredRPM = 0;
            EPPS_BIT_Code = 0;
            EPPS_Status_Flags = 0;
            EPPS_ResponseMessageCounter = 0;
        }

        public EPPSReponseMessage(CANMsg Msg)
        {
            if ((CAN_MESSAGE_ID)Msg.CANId != CAN_MESSAGE_ID.CAN_ID_REPONSE_MSG)
            {
                throw new Exception("Message does not have the ID of a Reponse Message!");
            }
            else
            {
                Current_EPPS_State = (EPPS_STATES)Msg.CANData[0];
                EPPS_BIT_Flags = Msg.CANData[1];
                EPPS_Status_Flags = Msg.CANData[2];
                RemainingRunTimeAtCurrentSpeed = Msg.CANData[3];
                MeasuredRPM = (ushort)((Msg.CANData[4] << 8) + Msg.CANData[5]);
                EPPS_BIT_Code = Msg.CANData[6];
                EPPS_ResponseMessageCounter = (Msg.CANData[7]);
            }
        }

    }

    class EPPS_InternalMessage1
    {
        //Raw Data Types
         public byte ControlInputs = 0;  
            //Bit 0 --> Start Permit
            //Bit 1 --> One PPS (Instaneous value)
            //Bit 2 --> Misc Input
            //Bit 3 --> Power Board Enabled
            //Bit 4 --> Power Board Report Master Fault

         public byte EncoderState = 0;
            //Bit 0 --> Phase A
            //Bit 1 --> Phase B
            //Bit 2 --> Phase C
            //Bit 3 --> Direction

        public byte PowerBoard_IGBT_Faults;
            //Bit 0 --> Low Side
            //Bit 1 --> Phase C High Side
            //Bit 2 --> Phase B High Side
            //Bit 3 --> Phase A High Side

        public byte PowerBoard_IsoPowerSupplys;
            //Bit 0 --> Low Side
            //Bit 1 --> Phase C High Side
            //Bit 2 --> Phase B High Side
            //Bit 3 --> Phase A High Side

        public ushort MeasuredEncoderRPM;

        const byte START_PERMIT_BIT_MASK = 0x01;
        const byte ONE_PPS_BIT_MASK = 0x02;
        const byte MISC_INPUT_BIT_MASK = 0x04;
        const byte POWER_BOARD_ENABLED_BIT_MASK = 0x08;
        const byte POWER_BOARD_FAULT_BIT_MASK = 0x10;

        const byte ENCODER_PH_A_BIT_MASK = 0x01;
        const byte ENCODER_PH_B_BIT_MASK = 0x02;
        const byte ENCODER_PH_C_BIT_MASK = 0x04;
        const byte ENCODER_DIR_BIT_MASK = 0x08;

        const byte  POWERBOARD_FAULT_IGBT_LOWER        =0x01;
        const byte  POWERBOARD_FAULT_IGBT_PHASE_C      =0x02;
        const byte  POWERBOARD_FAULT_IGBT_PHASE_B      =0x04;
        const byte  POWERBOARD_FAULT_IGBT_PHASE_A      =0x08;

        const byte  POWERBOARD_POWER_GOOD_LOWER       = 0x01;
        const byte  POWERBOARD_POWER_GOOD_PHASE_C    = 0x02;
        const byte  POWERBOARD_POWER_GOOD_PHASE_B    = 0x04;
        const byte  POWERBOARD_POWER_GOOD_PHASE_A    = 0x08;

        //Decoded states

        public bool StartPermitActive = false;
        public bool OnePPSActive = false;
        public bool MiscInputActive = false;
        public bool Encoder_Ph_A = false;
        public bool Encoder_Ph_B = false;
        public bool Encoder_Ph_C = false;
        public bool Encoder_Dir = false;
        public bool PowerBoardEnabled = false;
        public bool PowerBoardFault = false;

        public bool PhaseA_UpperPowerGood = false;
        public bool PhaseB_UpperPowerGood = false;
        public bool PhaseC_UpperPowerGood = false;
        public bool LowSidePowerGood = false;
        public bool PhaseA_IGBT_Fault = false;
        public bool PhaseB_IGBT_Fault = false;
        public bool PhaseC_IGBT_Fault = false;
        public bool LowSide_IGBT_Fault = false;

        public bool PowerBoardCommunicating = false;

        public EPPS_InternalMessage1(CANMsg InMsg)
        {
            if ((EPPS.CAN_MESSAGE_ID)InMsg.CANId == CAN_MESSAGE_ID.CAN_ID_INTERNAL_MSG_1)
            {
                ControlInputs = InMsg.CANData[0];
                EncoderState = InMsg.CANData[1];
                PowerBoard_IsoPowerSupplys = InMsg.CANData[2];
                PowerBoard_IGBT_Faults = InMsg.CANData[3];
                MeasuredEncoderRPM = (ushort)(((InMsg.CANData[4]) << 8) + InMsg.CANData[5]);
                
                //CONTROL INPUTS
                if((ControlInputs&START_PERMIT_BIT_MASK) > 0)
                    StartPermitActive = true;
                else
                    StartPermitActive = false;

                if ((ControlInputs & ONE_PPS_BIT_MASK) > 0)
                    OnePPSActive = true;
                else
                    OnePPSActive = false;

                if ((ControlInputs & MISC_INPUT_BIT_MASK) > 0)
                    MiscInputActive = true;
                else
                    MiscInputActive = false;

                if ((ControlInputs & POWER_BOARD_ENABLED_BIT_MASK) > 0)
                    PowerBoardEnabled = true;
                else
                    PowerBoardEnabled = false;

                if ((ControlInputs & POWER_BOARD_FAULT_BIT_MASK) > 0)
                    PowerBoardFault= true;
                else
                    PowerBoardFault = false;

                //ENCODER STATE
                if ((EncoderState & ENCODER_PH_A_BIT_MASK) > 0)
                    Encoder_Ph_A = true;
                else
                    Encoder_Ph_A = false;

                if ((EncoderState & ENCODER_PH_B_BIT_MASK) > 0)
                    Encoder_Ph_B = true;
                else
                    Encoder_Ph_B = false;

                if ((EncoderState & ENCODER_PH_C_BIT_MASK) > 0)
                    Encoder_Ph_C = true;
                else
                    Encoder_Ph_C = false;

                if ((EncoderState & ENCODER_DIR_BIT_MASK) > 0)
                    Encoder_Dir = true;
                else
                    Encoder_Dir = false;

                //IGBT Fault states.

                if (PowerBoard_IGBT_Faults == 0xFF & PowerBoard_IsoPowerSupplys == 0xFF)
                {
                          PhaseA_UpperPowerGood = false;
                          PhaseB_UpperPowerGood = false;
                          PhaseC_UpperPowerGood = false;
                          LowSidePowerGood = false;
                          PhaseA_IGBT_Fault = false;
                          PhaseB_IGBT_Fault = false;
                          PhaseC_IGBT_Fault = false;
                          LowSide_IGBT_Fault = false;
                          PowerBoardCommunicating = false;
                 }
                else
                {
                    PowerBoardCommunicating = true;

                    if ((PowerBoard_IGBT_Faults & POWERBOARD_FAULT_IGBT_LOWER) > 0)
                    {
                        LowSide_IGBT_Fault = true;
                    }
                    else
                    {
                        LowSide_IGBT_Fault = false;
                    }

                    if ((PowerBoard_IGBT_Faults & POWERBOARD_FAULT_IGBT_PHASE_A) > 0)
                    {
                        PhaseA_IGBT_Fault = true;
                    }
                    else
                    {
                        PhaseA_IGBT_Fault = false;
                    }

                    if ((PowerBoard_IGBT_Faults & POWERBOARD_FAULT_IGBT_PHASE_B) > 0)
                    {
                        PhaseB_IGBT_Fault = true;
                    }
                    else
                    {
                        PhaseB_IGBT_Fault = false;
                    }

                    if ((PowerBoard_IGBT_Faults & POWERBOARD_FAULT_IGBT_PHASE_C) > 0)
                    {
                        PhaseC_IGBT_Fault = true;
                    }
                    else
                    {
                        PhaseC_IGBT_Fault = false;
                    }

                    if ((PowerBoard_IsoPowerSupplys & POWERBOARD_POWER_GOOD_LOWER) > 0)
                    {
                        LowSidePowerGood = true;
                    }
                    else
                    {
                        LowSidePowerGood = false;
                    }


                    if ((PowerBoard_IsoPowerSupplys & POWERBOARD_POWER_GOOD_PHASE_A) > 0)
                    {
                        PhaseA_UpperPowerGood = true;
                    }
                    else
                    {
                        PhaseA_UpperPowerGood = false;
                    }

                    if ((PowerBoard_IsoPowerSupplys & POWERBOARD_POWER_GOOD_PHASE_B) > 0)
                    {
                        PhaseB_UpperPowerGood = true;
                    }
                    else
                    {
                        PhaseB_UpperPowerGood = false;
                    }

                    if ((PowerBoard_IsoPowerSupplys & POWERBOARD_POWER_GOOD_PHASE_C) > 0)
                    {
                        PhaseC_UpperPowerGood = true;
                    }
                    else
                    {
                        PhaseC_UpperPowerGood = false;
                    }
                }
              

            }
            else
            {
                throw new Exception("CAN Message ID is not CAN_ID_INTERNAL_MSG_1.  Expecting " + CAN_MESSAGE_ID.CAN_ID_INTERNAL_MSG_1 +
                     " recieved " + InMsg.CANId);

            }
        }

    }

    enum ATT_SUPERSTATES
    {
         SUPERSTATE_OFF           =0x00,
         SUPERSTATE_BOOTLOADER    =0xF0,
         SUPERSTATE_STANDBY       =0x10,
         SUPERSTATE_READY         =0x20,
         SUPERSTATE_LAUNCH        =0x30,
         SUPERSTATE_OPERATING     =0x40,
         SUPERSTATE_SHUTDOWN      =0x50,
         SUPERSTATE_NOT_READY     =0xA0,
         SUPERSTATE_TEST          =0xB0
    };

    enum EPPS_TEST_SUBSTATES
    {
         Test_ManualControl   = 0x01,
         Test_SpeedControl    = 0x02
    };

    enum EPPS_OFF_SUBSTATES
    {
            Off_Off = 0x01
    }

    public enum EPPS_STATES
    {
        EPPS_Off                = ATT_SUPERSTATES.SUPERSTATE_OFF + EPPS_OFF_SUBSTATES.Off_Off,
        EPPS_Test_ManualControl = ATT_SUPERSTATES.SUPERSTATE_TEST + EPPS_TEST_SUBSTATES.Test_ManualControl,
        EPPS_Test_SpeedControl  = ATT_SUPERSTATES.SUPERSTATE_TEST + EPPS_TEST_SUBSTATES.Test_SpeedControl
    };

    public enum EPPS_COMMAND
    {
         EPPS_NOP                = 0,
         EPPS_SEND_INTERNAL_DATA = 0x12,
         EPPS_STOP_INTERNAL_DATA = 0x14,
         EPPS_Test_ManualControl = EPPS_STATES.EPPS_Test_ManualControl,
         EPPS_Test_SpeedControl  = EPPS_STATES.EPPS_Test_SpeedControl,
         EPPS_Off = EPPS_STATES.EPPS_Off
    };

    public enum VC_STATE
    {
         VC_Off                                  =0x00,
         VC_Standby_Initialize                   =0x11,
         VC_Standby_WaitPresets                  =0x12,
 
         VC_Ready_InitialPresetsValid            =0x21,
         VC_Ready_WaitIntLaunchReqSig            =0x22,
         VC_Ready_WaitLaunchReqMsg               =0x23,
         VC_Ready_WaitFinalPresets               =0x24,
         VC_Ready_WaitSquibFireMsg               =0x25,

         VC_Launch_WaitIntPower                  =0x31,
         VC_Launch_WaitFirstMotion               =0x32,
         VC_Launch_BoreRiding                    =0x33,
         VC_Launch_AeroFlight                    =0x34,
         VC_Launch_WaterEntry                    =0x35,
         VC_Launch_TransitionToFlight            =0x36,
 
         VC_Operating_WaitPlatformSeparation     =0x41,
         VC_Operating_RunToMissionEnable         =0x42,
         VC_Operating_VCControl                  =0x43,
         VC_Operating_GCControl                  =0x44,
         VC_Operating_EndOfRunManeuvers          =0x45,

         VC_Shutdown_Delay                       =0x51,
         VC_Shutdown_PowerDown                   =0x52,
 
         VC_NotReady_BITFail                     =0xA1,
  
         VC_Test_WaitTestCommand                 =0xB1,
         VC_Test_UpdatingCode                    =0xB2,
         VC_Test_PerformingCommandedBIT          =0xB4,
         VC_Test_UpdatingCalibration             =0xB5,
         VC_Test_SendRecordedData                =0xB6,
         VC_Test_EraseRecordedData               =0xB7,
         VC_Test_SendRawData                     =0xB8,
         VC_Test_SendVersions                    =0xBA,
         VC_Test_TestOutputs                     =0xBB,
         VC_Test_EchoCalibration                 =0xBC
    };

    public enum TORPEDO_CONFIGURATION
    {
         Warshot                                  =  0x11,
         ExerciseInertInstrumentedWarheadThermal =   0x22,
         ExerciseFieldExerciseSectionThermal      =  0x33,
         ExerciseInertInstrumentedWarheadElectric  = 0x44,
         ExerciseFieldExerciseSectionElectric    =   0x55,
         Undefined                                 = 0xFC
    };

    public enum EPPS_OPERATING_STATE
    {
        EPPS_OPERATING_STATE_PERMITTED_1   = 0x11,
        EPPS_OPERATING_STATE_PERMITTED_2   = 0x22,
        EPPS_OPERATING_STATE_NOT_PERMITTED = 0x00
    };

    public enum CAN_MESSAGE_ID : uint
    {
         CAN_ID_COMMAND_MSG                     =0x18,
         CAN_ID_REPONSE_MSG                     =0x19,
         CAN_ID_VEHICLE_DATA_NETWORK_TIME_MSG   =0x34,
         CAN_ID_INTERNAL_MSG_1                  =0x418,
         CAN_ID_INTERNAL_MSG_2                  =0x419,
         CAN_ID_INTERNAL_MSG_3                  =0x41A,
         CAN_ID_INTERNAL_MSG_4                  =0x41B,
         CAN_ID_INTERNAL_MSG_5                  =0x41C,
         CAN_ID_INTERNAL_MSG_6                  =0x41D,
         CAN_ID_INTERNAL_MSG_7                  =0x41E,
         CAN_ID_INTERNAL_MSG_8                  =0x41F,
         CAN_ID_SUBSYSTEM_VERSION_MSG           =0x498,

         CAN_ID_TEST_COMMAND_MSG                 =0x598,
         CAN_ID_TEST_REPONSE_MSG                 =0x599,
         CAN_ID_TEST_DATA_OUT_MSG                =0x59A,
         CAN_ID_TEST_DATA_IN_MSG                 =0x59B,
         CAN_ID_TEST_DEBUG_STREAM_OUT_MSG        =0x59C,
         CAN_ID_TEST_DEBUG_STREAM_IN_MSG         =0x59D
    };

    public enum FPGA_COMMUTATION_DIRECTION
    {
        FORWARD = 1,
        REVERSE = 0
    };

    public enum FPGA_COMMUTATION_MODE
    {
        OPEN_LOOP = 0,
        CLOSED_LOOP = 1,
        MANUAL = 2
    };

    public enum FPGA_MANUAL_PHASE_MODE
    {
        FREE_0 = (0),
        PHASE_1 = (1),
        PHASE_2 = (2),
        PHASE_3 = (3),
        PHASE_4 = (4),
        PHASE_5 = (5),
        PHASE_6 = (6),
        FREE_7 = (7)
    };

    public enum EPPS_TEST_COMMAND
    {
        MANUAL_COMMUTATION_SETTINGS  = 1,
        TEST_COMMAND_ZERO_ADCS = 2,
        TEST_COMMAND_CHANGE_PWM_SETTINGS = 3
    };


    public class EPPS_ZeroADCs
    {
        public EPPS_TEST_COMMAND TestCommand = EPPS_TEST_COMMAND.TEST_COMMAND_ZERO_ADCS;
        public EPPS_ZeroADCs()
        {
            TestCommand = EPPS_TEST_COMMAND.TEST_COMMAND_ZERO_ADCS;
        }

        public CANMsg ToCANMsg()
        {
            CANMsg Msg = new CANMsg();

            Msg.CANId = (uint)CAN_MESSAGE_ID.CAN_ID_TEST_COMMAND_MSG;
            Msg.CANData = new byte[8];
            Msg.ExtendedID = false;
            Msg.RTR = false;
            Msg.CANData[0] = (byte)TestCommand;
            Msg.CANData[1] = (byte)0;
            Msg.CANData[2] = (byte)0;
            Msg.CANData[3] = (byte)0;
            Msg.CANData[4] = (byte)0;
            Msg.CANData[5] = (byte)0;
            Msg.CANData[6] = (byte)0;
            Msg.CANData[7] = (byte)0;

            return Msg;
        }
    }

    public class EPPS_ChangePWMSettings
    {
        public EPPS_TEST_COMMAND TestCommand = EPPS_TEST_COMMAND.TEST_COMMAND_CHANGE_PWM_SETTINGS;
        public ushort PWMFrequency;
        public ushort PWMSpreadRate;
            
        public EPPS_ChangePWMSettings()
        {
            TestCommand = EPPS_TEST_COMMAND.TEST_COMMAND_CHANGE_PWM_SETTINGS;
        }

        public CANMsg ToCANMsg()
        {
            CANMsg Msg = new CANMsg();

            Msg.CANId = (uint)CAN_MESSAGE_ID.CAN_ID_TEST_COMMAND_MSG;
            Msg.CANData = new byte[8];
            Msg.ExtendedID = false;
            Msg.RTR = false;
            Msg.CANData[0] = (byte)TestCommand;
            Msg.CANData[1] = (byte)0;
            Msg.CANData[2] = (byte)(PWMFrequency>>8);
            Msg.CANData[3] = (byte)(PWMFrequency);
            Msg.CANData[4] = (byte)(PWMSpreadRate>>8);
            Msg.CANData[5] = (byte)(PWMSpreadRate);
            Msg.CANData[6] = (byte)0;
            Msg.CANData[7] = (byte)0;

            return Msg;
        }
    }

    public class EPPS_ManualCommutationSettings
    {
        public EPPS_TEST_COMMAND TestCommand = EPPS_TEST_COMMAND.MANUAL_COMMUTATION_SETTINGS;
        public byte DutyCycle = 0;
        public FPGA_COMMUTATION_DIRECTION CommutationDirection = FPGA_COMMUTATION_DIRECTION.FORWARD;
        public FPGA_COMMUTATION_MODE CommutationMode = FPGA_COMMUTATION_MODE.CLOSED_LOOP;
        public FPGA_MANUAL_PHASE_MODE ManualPhase = FPGA_MANUAL_PHASE_MODE.FREE_0;
        public uint CommutationRate = 0;

        public EPPS_ManualCommutationSettings()
        {
            TestCommand = EPPS_TEST_COMMAND.MANUAL_COMMUTATION_SETTINGS;
            DutyCycle = 0;
            CommutationDirection = FPGA_COMMUTATION_DIRECTION.FORWARD;
            CommutationMode = FPGA_COMMUTATION_MODE.CLOSED_LOOP;
            ManualPhase = FPGA_MANUAL_PHASE_MODE.FREE_0;
            CommutationRate = 0;
        }

        public CANMsg ToCANMsg()
        {
            CANMsg Msg = new CANMsg();

            Msg.CANId = (uint)CAN_MESSAGE_ID.CAN_ID_TEST_COMMAND_MSG;
            Msg.CANData = new byte[8];
            Msg.ExtendedID = false;
            Msg.RTR = false;
            Msg.CANData[0] = (byte)TestCommand;
            Msg.CANData[1] = (byte)DutyCycle;
            Msg.CANData[2] = (byte)((byte)CommutationDirection | (byte)((byte)(ManualPhase)<<1));
            Msg.CANData[3] = (byte)CommutationMode;
            Msg.CANData[4] = (byte)(CommutationRate>>24);
            Msg.CANData[5] = (byte)(CommutationRate>>16);
            Msg.CANData[6] = (byte)(CommutationRate>>8);
            Msg.CANData[7] = (byte)(CommutationRate);

            return Msg;
        }

    }
}
